/*
 * Copyright 2024 LINE Corporation
 *
 * LINE Corporation licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package com.linecorp.centraldogma.server.internal.api;

import static com.linecorp.centraldogma.internal.CredentialUtil.credentialName;
import static com.linecorp.centraldogma.testing.internal.auth.TestAuthMessageUtil.PASSWORD;
import static com.linecorp.centraldogma.testing.internal.auth.TestAuthMessageUtil.USERNAME;
import static com.linecorp.centraldogma.testing.internal.auth.TestAuthMessageUtil.getAccessToken;
import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;

import org.junit.jupiter.api.extension.RegisterExtension;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import com.google.common.collect.ImmutableList;

import com.linecorp.armeria.client.BlockingWebClient;
import com.linecorp.armeria.client.WebClient;
import com.linecorp.armeria.client.WebClientBuilder;
import com.linecorp.armeria.common.AggregatedHttpResponse;
import com.linecorp.armeria.common.HttpStatus;
import com.linecorp.armeria.common.ResponseEntity;
import com.linecorp.armeria.common.auth.AuthToken;
import com.linecorp.centraldogma.client.CentralDogma;
import com.linecorp.centraldogma.client.armeria.ArmeriaCentralDogmaBuilder;
import com.linecorp.centraldogma.internal.api.v1.PushResultDto;
import com.linecorp.centraldogma.server.CentralDogmaBuilder;
import com.linecorp.centraldogma.server.credential.CreateCredentialRequest;
import com.linecorp.centraldogma.server.credential.Credential;
import com.linecorp.centraldogma.server.credential.CredentialType;
import com.linecorp.centraldogma.server.internal.credential.AccessTokenCredential;
import com.linecorp.centraldogma.server.internal.credential.NoneCredential;
import com.linecorp.centraldogma.server.internal.credential.PasswordCredential;
import com.linecorp.centraldogma.server.internal.credential.SshKeyCredential;
import com.linecorp.centraldogma.testing.internal.auth.TestAuthProviderFactory;
import com.linecorp.centraldogma.testing.junit.CentralDogmaExtension;

class CredentialServiceV1Test {

    private static final String FOO_PROJ = "foo-proj";
    private static final String BAR_REPO = "bar-repo";

    @RegisterExtension
    static final CentralDogmaExtension dogma = new CentralDogmaExtension() {

        @Override
        protected void configure(CentralDogmaBuilder builder) {
            builder.authProviderFactory(new TestAuthProviderFactory());
            builder.systemAdministrators(USERNAME);
        }

        @Override
        protected void configureHttpClient(WebClientBuilder builder) {
            // TODO(minwoox): Override accessToken to provide token to both WebClient and CentralDogma client.
            final String accessToken = getAccessToken(
                    WebClient.of("http://127.0.0.1:" + dogma.serverAddress().getPort()),
                    USERNAME, PASSWORD);
            builder.auth(AuthToken.ofOAuth2(accessToken));
        }

        @Override
        protected void configureClient(ArmeriaCentralDogmaBuilder builder) {
            final String accessToken = getAccessToken(
                    WebClient.of("http://127.0.0.1:" + dogma.serverAddress().getPort()),
                    USERNAME, PASSWORD);
            builder.accessToken(accessToken);
        }

        @Override
        protected void scaffold(CentralDogma client) {
            client.createProject(FOO_PROJ).join();
            client.createRepository(FOO_PROJ, BAR_REPO).join();
        }
    };

    @ValueSource(booleans = { true, false })
    @ParameterizedTest
    void createAndReadCredential(boolean projectLevel) {
        final List<CreateCredentialRequest> requests = ImmutableList.of(
                new CreateCredentialRequest(
                        "password-credential",
                        // name is automatically generated by the server.
                        new PasswordCredential(null, "username-0", "password-0")),
                new CreateCredentialRequest(
                        "access-token-credential",
                        new AccessTokenCredential(null, "secret-token-abc-1")),
                new CreateCredentialRequest(
                        "ssh-key-credential",
                        new SshKeyCredential(null, "username-2", "public-key-2", "private-key-2",
                                             "password-0")),
                new CreateCredentialRequest("non-credential", new NoneCredential(null)));

        final BlockingWebClient client = dogma.blockingHttpClient();
        for (int i = 0; i < requests.size(); i++) {
            final CreateCredentialRequest request = requests.get(i);
            final ResponseEntity<PushResultDto> creationResponse =
                    client.prepare()
                          .post(projectLevel ? "/api/v1/projects/" + FOO_PROJ + "/credentials"
                                             : "/api/v1/projects/" + FOO_PROJ + "/repos/" +
                                               BAR_REPO + "/credentials")
                          .contentJson(request)
                          .responseTimeoutMillis(0)
                          .asJson(PushResultDto.class)
                          .execute();
            assertThat(creationResponse.status()).isEqualTo(HttpStatus.CREATED);

            final Credential credential = request.credential();
            final String credentialName = name(projectLevel, request.credentialId());
            final ResponseEntity<Credential> fetchResponse =
                    client.prepare()
                          .get("/api/v1/" + credentialName)
                          .responseTimeoutMillis(0)
                          .asJson(Credential.class)
                          .execute();
            final Credential credentialDto = fetchResponse.content();
            assertThat(credentialDto.name()).isEqualTo(credentialName);
            final CredentialType credentialType = credential.type();
            if (credentialType == CredentialType.PASSWORD) {
                final PasswordCredential actual = (PasswordCredential) credentialDto;
                assertThat(credential).isInstanceOf(PasswordCredential.class);
                final PasswordCredential passwordCredential = (PasswordCredential) credential;
                assertThat(actual.username()).isEqualTo(passwordCredential.username());
                assertThat(actual.password()).isEqualTo(passwordCredential.rawPassword());
            } else if (credentialType == CredentialType.ACCESS_TOKEN) {
                final AccessTokenCredential actual = (AccessTokenCredential) credentialDto;
                assertThat(credential).isInstanceOf(AccessTokenCredential.class);
                final AccessTokenCredential accessTokenCredential = (AccessTokenCredential) credential;
                assertThat(actual.accessToken()).isEqualTo(accessTokenCredential.accessToken());
            } else if (credentialType == CredentialType.SSH_KEY) {
                final SshKeyCredential actual = (SshKeyCredential) credentialDto;
                assertThat(credential).isInstanceOf(SshKeyCredential.class);
                final SshKeyCredential sshKeyCredential = (SshKeyCredential) credential;
                assertThat(actual.username()).isEqualTo(sshKeyCredential.username());
                assertThat(actual.publicKey()).isEqualTo(sshKeyCredential.publicKey());
                assertThat(actual.rawPrivateKey()).isEqualTo(sshKeyCredential.rawPrivateKey());
                assertThat(actual.rawPassphrase()).isEqualTo(sshKeyCredential.rawPassphrase());
            } else if (credentialType == CredentialType.NONE) {
                assertThat(credentialDto).isInstanceOf(NoneCredential.class);
            } else {
                throw new AssertionError("Unexpected credential type: " + credential.getClass().getName());
            }
        }

        for (int i = 0; i < requests.size(); i++) {
            final CreateCredentialRequest request = requests.get(i);
            final AggregatedHttpResponse deletionResponse =
                    client.prepare()
                          .delete(projectLevel ? "/api/v1/projects/" + FOO_PROJ +
                                                 "/credentials/" + request.credentialId()
                                               : "/api/v1/projects/" + FOO_PROJ + "/repos/" +
                                                 BAR_REPO + "/credentials/" + request.credentialId())
                          .execute();
            assertThat(deletionResponse.status()).isEqualTo(HttpStatus.NO_CONTENT);
        }
    }

    private static String name(boolean projectLevel, String credentialId) {
        return projectLevel ? credentialName(FOO_PROJ, credentialId)
                            : credentialName(FOO_PROJ, BAR_REPO, credentialId);
    }
}
