/*
 * Copyright 2024 LINE Corporation
 *
 * LINE Corporation licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.linecorp.centraldogma.server.management;

import static java.util.Objects.requireNonNull;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Properties;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import com.linecorp.armeria.common.util.ThreadFactories;

/**
 * Manages the server status.
 */
public final class ServerStatusManager {

    private static final String STATUS = "status";

    private final Executor sequentialExecutor =
            Executors.newSingleThreadExecutor(
                    ThreadFactories.newThreadFactory("server-status-manager", true));

    private final Path serverStatusFile;

    /**
     * Creates a new instance with the specified {@code dataDir}.
     */
    public ServerStatusManager(File dataDir) {
        requireNonNull(dataDir, "dataDir");
        final File serverStatusFile = new File(dataDir, "server-status.properties");
        // Create the file if it does not exist.
        try {
            serverStatusFile.createNewFile();
        } catch (IOException e) {
            throw new IllegalStateException("Failed to create server status file: " + serverStatusFile, e);
        }
        this.serverStatusFile = serverStatusFile.toPath();
    }

    /**
     * Reads the {@link ServerStatus} from the {@code "<data-dir>/server-status.properties"} file.
     *
     * <p>The stored {@link ServerStatus} may be used to determine whether the server is writable and
     * replicating when the server is started.
     */
    public ServerStatus serverStatus() {
        final Properties properties = new Properties();
        synchronized (serverStatusFile) {
            try {
                properties.load(Files.newInputStream(serverStatusFile));
            } catch (IOException e) {
                throw new IllegalStateException("Failed to load server status file: " + serverStatusFile, e);
            }
        }

        final String status = properties.getProperty(STATUS, "WRITABLE");
        return ServerStatus.valueOf(status);
    }

    /**
     * Updates the server status with the specified {@code writable} and {@code replicating} values.
     *
     * <p>The status may be stored in the {@code "<data-dir>/server-status.properties"} file so that the server
     * can be initialized with the same status when it is restarted.
     */
    public void updateStatus(ServerStatus newServerStatus) {
        synchronized (serverStatusFile) {
            final Properties properties = new Properties();
            try {
                properties.load(Files.newInputStream(serverStatusFile));
            } catch (IOException e) {
                throw new IllegalStateException("Failed to load server status file: " + serverStatusFile,
                                                e);
            }
            properties.setProperty(STATUS, newServerStatus.name());
            try {
                properties.store(Files.newOutputStream(serverStatusFile),
                                 "Do not edit this file manually. Use the AdministrativeService API.");
            } catch (IOException e) {
                throw new IllegalStateException("Failed to store server status file: " + serverStatusFile,
                                                e);
            }
        }
    }

    /**
     * Returns the {@link Executor} which is used to execute the status update sequentially.
     */
    public Executor sequentialExecutor() {
        return sequentialExecutor;
    }
}
